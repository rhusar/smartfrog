/* Generated By:JavaCC: Do not edit this line. DefaultParser.java */
package org.smartfrog.sfcore.languages.sf;

import org.smartfrog.sfcore.languages.sf.sfcomponentdescription.SFComponentDescriptionImpl;
import org.smartfrog.sfcore.languages.sf.sfcomponentdescription.SFComponentDescription;
import org.smartfrog.sfcore.languages.sf.sfreference.SFApplyReference;
import org.smartfrog.sfcore.languages.sf.sfreference.SFReference;
import org.smartfrog.sfcore.languages.sf.sfreference.SFAssertReference;
import org.smartfrog.sfcore.languages.sf.sfreference.SFTBDReference;
import org.smartfrog.sfcore.languages.sf.constraints.FreeVar;
import org.smartfrog.sfcore.languages.sf.IncludeHandler;

import org.smartfrog.sfcore.reference.ReferencePart;
import org.smartfrog.sfcore.reference.HostReferencePart;
import org.smartfrog.sfcore.reference.PropertyReferencePart;
import org.smartfrog.sfcore.reference.IPropertyReferencePart;
import org.smartfrog.sfcore.reference.EnvPropertyReferencePart;
import org.smartfrog.sfcore.reference.IEnvPropertyReferencePart;
import org.smartfrog.sfcore.reference.HereReferencePart;
import org.smartfrog.sfcore.reference.RootReferencePart;
import org.smartfrog.sfcore.reference.AttribReferencePart;
import org.smartfrog.sfcore.reference.ThisReferencePart;

import org.smartfrog.sfcore.componentdescription.ComponentDescription;
import org.smartfrog.sfcore.common.Context;


import org.smartfrog.sfcore.common.SFNull;
import org.smartfrog.sfcore.common.SFByteArray;
import org.smartfrog.sfcore.common.SmartFrogException;
import java.io.Reader;
import java.util.Vector;
import java.util.Enumeration;
import java.util.Set;
import java.util.HashSet;

public class DefaultParser implements DefaultParserConstants {
  protected IncludeHandler includeHandler;
  public static int nextId = 0;

  static final String appendOp = "org.smartfrog.sfcore.languages.sf.functions.Append";
  static final String concatOp = "org.smartfrog.sfcore.languages.sf.functions.Concatenate";
  static final String sumOp = "org.smartfrog.sfcore.languages.sf.functions.Sum";
  static final String timesOp = "org.smartfrog.sfcore.languages.sf.functions.Product";

  static final String andOp = "org.smartfrog.sfcore.languages.sf.functions.And";
  static final String orOp = "org.smartfrog.sfcore.languages.sf.functions.Or";
  static final String xorOp = "org.smartfrog.sfcore.languages.sf.functions.Xor";
  static final String impliesOp = "org.smartfrog.sfcore.languages.sf.functions.Implies";

  static final String eqOp = "org.smartfrog.sfcore.languages.sf.functions.EQ";
  static final String neOp = "org.smartfrog.sfcore.languages.sf.functions.NE";
  static final String geOp = "org.smartfrog.sfcore.languages.sf.functions.GE";
  static final String leOp = "org.smartfrog.sfcore.languages.sf.functions.LE";
  static final String gtOp = "org.smartfrog.sfcore.languages.sf.functions.GT";
  static final String ltOp = "org.smartfrog.sfcore.languages.sf.functions.LT";

  static final String minusOp = "org.smartfrog.sfcore.languages.sf.functions.Minus";
  static final String divOp = "org.smartfrog.sfcore.languages.sf.functions.Divide";
  static final String modOp = "org.smartfrog.sfcore.languages.sf.functions.Mod";

  static final String notOp = "org.smartfrog.sfcore.languages.sf.functions.Not";
  static final String ifThenElseOp = "org.smartfrog.sfcore.languages.sf.functions.IfThenElse";
  static final String switchOp = "org.smartfrog.sfcore.languages.sf.functions.Switch";

  static final String functionPhaseClass = "org.smartfrog.sfcore.languages.sf.ConstructFunction";

  static final String tbdOp = "org.smartfrog.sfcore.languages.sf.predicates.TBD";


  public DefaultParser(Reader is, IncludeHandler handler) {
    this(is);
    this.includeHandler = handler;
  }


  private String fixEscapes(String s) {
    int index = 0;
    int length = s.length();
    StringBuffer fixed = new StringBuffer(length);

    while (index < length) {
      if (s.charAt(index) == '\\') {
        index++;
        switch (s.charAt(index)) {
          case 'n':
            fixed.append('\n'); break;
          case 't':
            fixed.append('\t'); break;
          case 'b':
            fixed.append('\b'); break;
          case 'r':
            fixed.append('\r'); break;
          case 'f':
            fixed.append('\f'); break;
          case '0': case '1': case '2': case '3':
          case '4': case '5': case '6': case '7':
            int i = ((s.charAt(index) - '0') * 64) +
                    ((s.charAt(index+1) - '0') * 8) +
                    ((s.charAt(index+2) - '0'));
            index = index + 2;
            fixed.append((char) i);
            break;
          default:
            fixed.append(s.charAt(index));
        }
      } else {
        fixed.append(s.charAt(index));
      }
      index++;
    }
    return fixed.toString();
  }

  private String eliminateWhitespace(String s) {
    int index = 0;
    int length = s.length();
    StringBuffer fixed = new StringBuffer();

    while (index < length) {
        switch (s.charAt(index)) {
          case '\n':
          case '\t':
          case ' ':
            break;
          default:
            fixed.append(s.charAt(index));
        }
        index++;
    }
    return fixed.toString();
  }


  protected Vector parseInclude(String fName, String codebase) throws ParseException {
    try {
      return includeHandler.parseInclude(fName, codebase);
    } catch (TokenMgrError tex) {
      throw new TokenMgrError("In include file " + fName
                              +(codebase != null? ("in code base "+ codebase):"")
                              + " : " +
                              tex.getMessage(),
                              tex.errorCode);
    } catch (Exception ex) {
      ParseException pe=new ParseException("Parsing include file " + fName
                +(codebase != null? ("in code base "+ codebase):"")
                + " : " + ex.getMessage());
      pe.initCause(ex);
      throw pe;
    }
  }

/*
 * Entry point to the grammar for component parser
 */
  final public void Attributes(SFComponentDescription descr) throws ParseException {
    AttributesNoEOF(descr);
    jj_consume_token(0);
  }

/*
 * Entry point for default include handler
 */
  final public Vector AttributeList() throws ParseException {
    Vector res;
    res = AttributeListNoEOF();
    jj_consume_token(0);
      {if (true) return res;}
    throw new Error("Missing return statement in function");
  }

/*
 * Entry point for Reference parser
 */
  final public SFReference Reference() throws ParseException {
  SFReference res;
    res = ReferenceNoEOF();
    jj_consume_token(0);
      {if (true) return res;}
    throw new Error("Missing return statement in function");
  }

/*
 * Entry point for any value parser (e.g. for parsing values in Management Console)
 */
  final public Object AnyValue() throws ParseException {
  Object res;
    switch (jj_nt.kind) {
    case EXTENDS:
      res = Component();
      break;
    case APPLY:
    case ASSERT:
    case ATTRIB:
    case DATA:
    case FALSE:
    case HERE:
    case HOST:
    case PROPERTY:
    case IPROPERTY:
    case ENVPROPERTY:
    case IENVPROPERTY:
    case CONST:
    case LAZY:
    case LBRACKET:
    case NULL:
    case OPTIONAL:
    case PARENT:
    case PROCESS:
    case ROOT:
    case TBD:
    case THIS:
    case TRUE:
    case VECTORSTART:
    case OPSTART:
    case IF:
    case SWITCH:
    case VAR:
    case WORD:
    case STRING:
    case MULTILINESTRING:
    case INTEGER:
    case DOUBLE:
    case LONG:
    case FLOAT:
    case BYTEARRAY:
      res = SimpleValue();
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(0);
       {if (true) return res;}
    throw new Error("Missing return statement in function");
  }

 /*
  * Entry point for basic value parser (e.g. for parsing properties)
  */
  final public Object PrimitiveValue() throws ParseException {
  Object res;
    res = Primitive();
    jj_consume_token(0);
      {if (true) return res;}
    throw new Error("Missing return statement in function");
  }

 /*
  * Entry point for tags parser (e.g. for tags in management console)
  */
  final public Object TagsSet() throws ParseException {
  Set tags = new HashSet();
    switch (jj_nt.kind) {
    case LBRACKET:
      jj_consume_token(LBRACKET);
      Tags(tags);
      jj_consume_token(RBRACKET);
      break;
    default:
      jj_la1[1] = jj_gen;
      ;
    }
    jj_consume_token(0);
      {if (true) return tags;}
    throw new Error("Missing return statement in function");
  }

/*
 * Main body of grammar
 */
  final public void AttributesNoEOF(SFComponentDescription descr) throws ParseException {
  Vector attrs;
    attrs = AttributeListNoEOF();
    for (Enumeration e = attrs.elements(); e.hasMoreElements(); ) {
      Object[] attribute = (Object[])e.nextElement();
      descr.sfContext().put(attribute[0], attribute[1]);
      try {
         if (((Set)attribute[2]).size() > 0)descr.sfContext().sfSetTags(attribute[0], (Set)attribute[2]);
      } catch (SmartFrogException sce) {
         //shouldn't happen
         sce.printStackTrace();
      }
      if (attribute[1] instanceof SFComponentDescription)
        ((SFComponentDescription)attribute[1]).setParent(descr);
    }
  }

  final public Vector AttributeListNoEOF() throws ParseException {
    Vector res = new Vector(10, 5);
    Object[] c;
    label_1:
    while (true) {
      switch (jj_nt.kind) {
      case CODEBASE:
      case INCLUDE:
      case LBRACKET:
      case SEMICOLON:
      case UNIQUE:
      case WORD:
      case STRING:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_1;
      }
      switch (jj_nt.kind) {
      case LBRACKET:
      case UNIQUE:
      case WORD:
      case STRING:
        c = Attribute();
                       res.addElement(c);
        break;
      case CODEBASE:
      case INCLUDE:
        Includes(res);
        break;
      case SEMICOLON:
        jj_consume_token(SEMICOLON);
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return res;}
    throw new Error("Missing return statement in function");
  }

  final public void Includes(Vector res) throws ParseException {
     String codebase = null;
     String fName;
    switch (jj_nt.kind) {
    case CODEBASE:
      jj_consume_token(CODEBASE);
      codebase = String();
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
    jj_consume_token(INCLUDE);
    fName = String();
           Vector tmp = parseInclude(fName, codebase);
           for(Enumeration e = tmp.elements(); e.hasMoreElements(); )
             res.addElement(e.nextElement());
  }

  final public Object[] Attribute() throws ParseException {
  Object[] attribute = new Object[3];
  SFReference name = new SFReference();
  Set tags = new HashSet();
    switch (jj_nt.kind) {
    case LBRACKET:
      jj_consume_token(LBRACKET);
      Tags(tags);
      jj_consume_token(RBRACKET);
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
    AttrName(name);
    attribute[1] = Value();
     if (name.size() == 1)
        attribute[0] = ((HereReferencePart)name.firstElement()).getValue();
      else
        attribute[0] = name;
     if (attribute[1] == null) attribute[1] = SFNull.get();
     attribute[2] = tags;
     {if (true) return attribute;}
    throw new Error("Missing return statement in function");
  }

  final public void Tags(Set tags) throws ParseException {
    Token t;
    switch (jj_nt.kind) {
    case WORD:
    case STRING:
    case MULTILINESTRING:
      t = Name();
               tags.add(t.image);
      switch (jj_nt.kind) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        jj_la1[6] = jj_gen;
        ;
      }
      Tags(tags);
      break;
    default:
      jj_la1[7] = jj_gen;
      ;
    }
  }

  final public void AttrName(SFReference res) throws ParseException {
  res.setEager(true);
  Token t;
    switch (jj_nt.kind) {
    case UNIQUE:
      jj_consume_token(UNIQUE);
           res.addElement(ReferencePart.here("unique" + nextId++));
      break;
    case STRING:
      t = jj_consume_token(STRING);
                       res.addElement(ReferencePart.here(fixEscapes(t.image.substring(1, t.image.length() - 1))));
      break;
    case WORD:
      t = jj_consume_token(WORD);
                  res.addElement(ReferencePart.here(t.image));
      switch (jj_nt.kind) {
      case REFPARTSEP:
        jj_consume_token(REFPARTSEP);
        AttrName(res);
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public Object Value() throws ParseException {
  Object res=null;
    switch (jj_nt.kind) {
    case EXTENDS:
      res = Component();
      break;
    case APPLY:
    case ASSERT:
    case ATTRIB:
    case DATA:
    case FALSE:
    case HERE:
    case HOST:
    case PROPERTY:
    case IPROPERTY:
    case ENVPROPERTY:
    case IENVPROPERTY:
    case CONST:
    case LAZY:
    case LBRACKET:
    case NULL:
    case OPTIONAL:
    case PARENT:
    case PROCESS:
    case ROOT:
    case TBD:
    case THIS:
    case TRUE:
    case VECTORSTART:
    case OPSTART:
    case IF:
    case SWITCH:
    case VAR:
    case WORD:
    case STRING:
    case MULTILINESTRING:
    case INTEGER:
    case DOUBLE:
    case LONG:
    case FLOAT:
    case BYTEARRAY:
      res = SimpleValue();
      break;
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return res;}
    throw new Error("Missing return statement in function");
  }

  final public Object Var() throws ParseException {
   Object ran = null;
   Object val = null;
    jj_consume_token(VAR);
    switch (jj_nt.kind) {
    case APPLY:
    case ASSERT:
    case ATTRIB:
    case HERE:
    case HOST:
    case PROPERTY:
    case IPROPERTY:
    case ENVPROPERTY:
    case IENVPROPERTY:
    case CONST:
    case LAZY:
    case LBRACE:
    case OPTIONAL:
    case PARENT:
    case PROCESS:
    case ROOT:
    case THIS:
    case WORD:
    case STRING:
    case MULTILINESTRING:
      switch (jj_nt.kind) {
      case APPLY:
      case ASSERT:
      case ATTRIB:
      case HERE:
      case HOST:
      case PROPERTY:
      case IPROPERTY:
      case ENVPROPERTY:
      case IENVPROPERTY:
      case CONST:
      case LAZY:
      case OPTIONAL:
      case PARENT:
      case PROCESS:
      case ROOT:
      case THIS:
      case WORD:
      case STRING:
      case MULTILINESTRING:
        switch (jj_nt.kind) {
        case APPLY:
        case ASSERT:
        case ATTRIB:
        case HERE:
        case HOST:
        case PROPERTY:
        case IPROPERTY:
        case ENVPROPERTY:
        case IENVPROPERTY:
        case CONST:
        case LAZY:
        case OPTIONAL:
        case PARENT:
        case PROCESS:
        case ROOT:
        case THIS:
        case WORD:
          ran = ReferenceNoEOF();
          break;
        case STRING:
        case MULTILINESTRING:
          ran = String();
          break;
        default:
          jj_la1[11] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case LBRACE:
        jj_consume_token(LBRACE);
        switch (jj_nt.kind) {
        case APPLY:
        case ASSERT:
        case ATTRIB:
        case HERE:
        case HOST:
        case PROPERTY:
        case IPROPERTY:
        case ENVPROPERTY:
        case IENVPROPERTY:
        case CONST:
        case LAZY:
        case OPTIONAL:
        case PARENT:
        case PROCESS:
        case ROOT:
        case THIS:
        case WORD:
          ran = ReferenceNoEOF();
          break;
        case STRING:
        case MULTILINESTRING:
          ran = String();
          break;
        default:
          jj_la1[12] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(COMMA);
        switch (jj_nt.kind) {
        case STRING:
        case MULTILINESTRING:
          val = String();
          break;
        case INTEGER:
        case DOUBLE:
        case LONG:
        case FLOAT:
          val = Number();
          break;
        default:
          jj_la1[13] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(RBRACE);
        break;
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
         {if (true) return new FreeVar(ran, val);}
      break;
    default:
      jj_la1[15] = jj_gen;
           {if (true) return new FreeVar();}
    }
    throw new Error("Missing return statement in function");
  }

  final public Object SimpleValue() throws ParseException {
  Object res=null;
    switch (jj_nt.kind) {
    case APPLY:
    case ASSERT:
    case ATTRIB:
    case HERE:
    case HOST:
    case PROPERTY:
    case IPROPERTY:
    case ENVPROPERTY:
    case IENVPROPERTY:
    case CONST:
    case LAZY:
    case OPTIONAL:
    case PARENT:
    case PROCESS:
    case ROOT:
    case THIS:
    case WORD:
      res = ReferenceNoEOF();
      break;
    case DATA:
    case FALSE:
    case LBRACKET:
    case NULL:
    case TBD:
    case TRUE:
    case VECTORSTART:
    case VAR:
    case STRING:
    case MULTILINESTRING:
    case INTEGER:
    case DOUBLE:
    case LONG:
    case FLOAT:
    case BYTEARRAY:
      res = Basic();
      break;
    case OPSTART:
      jj_consume_token(OPSTART);
      switch (jj_nt.kind) {
      case EXTENDS:
        res = Component();
        break;
      case APPLY:
      case ASSERT:
      case ATTRIB:
      case DATA:
      case FALSE:
      case HERE:
      case HOST:
      case PROPERTY:
      case IPROPERTY:
      case ENVPROPERTY:
      case IENVPROPERTY:
      case CONST:
      case LAZY:
      case LBRACKET:
      case NULL:
      case OPTIONAL:
      case PARENT:
      case PROCESS:
      case ROOT:
      case TBD:
      case THIS:
      case TRUE:
      case VECTORSTART:
      case OPSTART:
      case NOT:
      case IF:
      case SWITCH:
      case VAR:
      case WORD:
      case STRING:
      case MULTILINESTRING:
      case INTEGER:
      case DOUBLE:
      case LONG:
      case FLOAT:
      case BYTEARRAY:
        res = Operator();
        break;
      default:
        jj_la1[16] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(OPEND);
      break;
    case IF:
      res = IfThenElse();
      break;
    case SWITCH:
      res = Switch();
      break;
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return res;}
    throw new Error("Missing return statement in function");
  }

  final public Object Operator() throws ParseException {
    Object res;
    int arity = 0; //0=nary, 1=unary, 2=binary

    Object a = null;
    Object b = null;
    Vector v = new Vector();
    String operator = "";
    switch (jj_nt.kind) {
    case NOT:
      jj_consume_token(NOT);
             operator = notOp; arity = 1;
      a = SimpleValue();
      break;
    case APPLY:
    case ASSERT:
    case ATTRIB:
    case DATA:
    case FALSE:
    case HERE:
    case HOST:
    case PROPERTY:
    case IPROPERTY:
    case ENVPROPERTY:
    case IENVPROPERTY:
    case CONST:
    case LAZY:
    case LBRACKET:
    case NULL:
    case OPTIONAL:
    case PARENT:
    case PROCESS:
    case ROOT:
    case TBD:
    case THIS:
    case TRUE:
    case VECTORSTART:
    case OPSTART:
    case IF:
    case SWITCH:
    case VAR:
    case WORD:
    case STRING:
    case MULTILINESTRING:
    case INTEGER:
    case DOUBLE:
    case LONG:
    case FLOAT:
    case BYTEARRAY:
      a = SimpleValue();
                         v.add(a);
      switch (jj_nt.kind) {
      case SUM:
      case MINUS:
      case TIMES:
      case DIV:
      case MOD:
      case CONCAT:
      case APPEND:
      case EQ:
      case NE:
      case GE:
      case LE:
      case GT:
      case LT:
      case AND:
      case OR:
      case XOR:
      case IMPLIES:
        switch (jj_nt.kind) {
        case APPEND:
          jj_consume_token(APPEND);
                  operator = appendOp; arity=0;
          b = SimpleValue();
                                                                      v.add(b);
          label_2:
          while (true) {
            switch (jj_nt.kind) {
            case APPEND:
              ;
              break;
            default:
              jj_la1[18] = jj_gen;
              break label_2;
            }
            jj_consume_token(APPEND);
            b = SimpleValue();
                                                                                                                v.add(b);
          }
          break;
        case CONCAT:
          jj_consume_token(CONCAT);
                      operator = concatOp; arity=0;
          b = SimpleValue();
                                                                          v.add(b);
          label_3:
          while (true) {
            switch (jj_nt.kind) {
            case CONCAT:
              ;
              break;
            default:
              jj_la1[19] = jj_gen;
              break label_3;
            }
            jj_consume_token(CONCAT);
            b = SimpleValue();
                                                                                                                    v.add(b);
          }
          break;
        case SUM:
          jj_consume_token(SUM);
                   operator = sumOp; arity=0;
          b = SimpleValue();
                                                                    v.add(b);
          label_4:
          while (true) {
            switch (jj_nt.kind) {
            case SUM:
              ;
              break;
            default:
              jj_la1[20] = jj_gen;
              break label_4;
            }
            jj_consume_token(SUM);
            b = SimpleValue();
                                                                                                           v.add(b);
          }
          break;
        case TIMES:
          jj_consume_token(TIMES);
                     operator = timesOp; arity=0;
          b = SimpleValue();
                                                                        v.add(b);
          label_5:
          while (true) {
            switch (jj_nt.kind) {
            case TIMES:
              ;
              break;
            default:
              jj_la1[21] = jj_gen;
              break label_5;
            }
            jj_consume_token(TIMES);
            b = SimpleValue();
                                                                                                                 v.add(b);
          }
          break;
        case AND:
          jj_consume_token(AND);
                   operator = andOp; arity=0;
          b = SimpleValue();
                                                                    v.add(b);
          label_6:
          while (true) {
            switch (jj_nt.kind) {
            case AND:
              ;
              break;
            default:
              jj_la1[22] = jj_gen;
              break label_6;
            }
            jj_consume_token(AND);
            b = SimpleValue();
                                                                                                           v.add(b);
          }
          break;
        case OR:
          jj_consume_token(OR);
                  operator = orOp; arity=0;
          b = SimpleValue();
                                                                  v.add(b);
          label_7:
          while (true) {
            switch (jj_nt.kind) {
            case OR:
              ;
              break;
            default:
              jj_la1[23] = jj_gen;
              break label_7;
            }
            jj_consume_token(OR);
            b = SimpleValue();
                                                                                                        v.add(b);
          }
          break;
        case XOR:
          jj_consume_token(XOR);
                   operator = xorOp; arity=0;
          b = SimpleValue();
                                                                    v.add(b);
          label_8:
          while (true) {
            switch (jj_nt.kind) {
            case XOR:
              ;
              break;
            default:
              jj_la1[24] = jj_gen;
              break label_8;
            }
            jj_consume_token(XOR);
            b = SimpleValue();
                                                                                                           v.add(b);
          }
          break;
        case IMPLIES:
          jj_consume_token(IMPLIES);
                       operator = impliesOp; arity=0;
          b = SimpleValue();
                                                                            v.add(b);
          label_9:
          while (true) {
            switch (jj_nt.kind) {
            case IMPLIES:
              ;
              break;
            default:
              jj_la1[25] = jj_gen;
              break label_9;
            }
            jj_consume_token(IMPLIES);
            b = SimpleValue();
                                                                                                                       v.add(b);
          }
          break;
        case EQ:
          jj_consume_token(EQ);
              operator = eqOp; arity=2;
          b = SimpleValue();
          break;
        case NE:
          jj_consume_token(NE);
              operator = neOp; arity=2;
          b = SimpleValue();
          break;
        case GE:
          jj_consume_token(GE);
              operator = geOp; arity=2;
          b = SimpleValue();
          break;
        case LE:
          jj_consume_token(LE);
              operator = leOp; arity=2;
          b = SimpleValue();
          break;
        case GT:
          jj_consume_token(GT);
              operator = gtOp; arity=2;
          b = SimpleValue();
          break;
        case LT:
          jj_consume_token(LT);
              operator = ltOp; arity=2;
          b = SimpleValue();
          break;
        case MINUS:
          jj_consume_token(MINUS);
                 operator = minusOp; arity=2;
          b = SimpleValue();
          break;
        case DIV:
          jj_consume_token(DIV);
               operator = divOp; arity=2;
          b = SimpleValue();
          break;
        case MOD:
          jj_consume_token(MOD);
               operator = modOp; arity=2;
          b = SimpleValue();
          break;
        default:
          jj_la1[26] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[27] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[28] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (operator.equals("")) {
        res = a;
    } else {
        res = SFParser.componentFactory("default");
        if (arity==0) {
        for (Enumeration e = v.elements(); e.hasMoreElements(); ) {
            Object attribute = e.nextElement();
            ((SFComponentDescription)res).sfContext().put("unique" + nextId++, attribute);
            if (attribute instanceof SFComponentDescription)
            ((SFComponentDescription)attribute).setParent((SFComponentDescription)res);
        }
        } else if (arity == 2) {
        ((SFComponentDescription)res).sfContext().put("left", a);
        if (a instanceof SFComponentDescription)
            ((SFComponentDescription)a).setParent((SFComponentDescription)res);
        ((SFComponentDescription)res).sfContext().put("right", b);
        if (b instanceof SFComponentDescription)
            ((SFComponentDescription)b).setParent((SFComponentDescription)res);
        } else { // (arity == 1)
        ((SFComponentDescription)res).sfContext().put("data", a);
        if (a instanceof SFComponentDescription)
            ((SFComponentDescription)a).setParent((SFComponentDescription)res);
        }
        ((SFComponentDescription)res).sfContext().put("phase.function", functionPhaseClass);
        ((SFComponentDescription)res).sfContext().put("sfFunctionClass", operator);
    }
    {if (true) return res;}
    throw new Error("Missing return statement in function");
  }

  final public Object IfThenElse() throws ParseException {
    Object i,t,e;
    jj_consume_token(IF);
    i = SimpleValue();
    jj_consume_token(THEN);
    t = SimpleValue();
    jj_consume_token(ELSE);
    e = SimpleValue();
    jj_consume_token(FI);
    SFComponentDescription ifte = SFParser.componentFactory("default");
    if (i instanceof SFComponentDescription)
        ((SFComponentDescription)i).setParent((SFComponentDescription)ifte);

    if (t instanceof SFComponentDescription)
        ((SFComponentDescription)t).setParent((SFComponentDescription)ifte);

    if (e instanceof SFComponentDescription)
        ((SFComponentDescription)e).setParent((SFComponentDescription)ifte);

    ifte.sfContext().put("phase.function", functionPhaseClass);
    ifte.sfContext().put("sfFunctionClass", ifThenElseOp);

    ifte.sfContext().put("if", i);
    ifte.sfContext().put("then", t);
    ifte.sfContext().put("else", e);
    {if (true) return ifte;}
    throw new Error("Missing return statement in function");
  }

  final public Object Switch() throws ParseException {
    SFComponentDescription bindings = SFParser.componentFactory("default");
        bindings.sfContext().put("phase.function", functionPhaseClass);
        bindings.sfContext().put("sfFunctionClass", switchOp);
    jj_consume_token(SWITCH);
    switch (jj_nt.kind) {
    case LBRACE:
      jj_consume_token(LBRACE);
      AttributesNoEOF(bindings);
      jj_consume_token(RBRACE);
      break;
    default:
      jj_la1[29] = jj_gen;
      ;
    }
    CaseList(bindings);
    jj_consume_token(ENDSWITCH);
        {if (true) return bindings;}
    throw new Error("Missing return statement in function");
  }

  final public void CaseList(SFComponentDescription cases) throws ParseException {
    Object i,t;
    jj_consume_token(IF);
    i = SimpleValue();
    jj_consume_token(THEN);
    t = SimpleValue();
      cases.sfContext().put("IF" + nextId, i);
      if (i instanceof SFComponentDescription) {
            ((SFComponentDescription)i).setParent((SFComponentDescription)cases);
      }
      cases.sfContext().put("THEN" + nextId++, t);
      if (t instanceof SFComponentDescription) {
            ((SFComponentDescription)t).setParent((SFComponentDescription)cases);
      }
    switch (jj_nt.kind) {
    case IF:
      CaseList(cases);
      break;
    default:
      jj_la1[30] = jj_gen;
      ;
    }
  }

//
// Note that the Component() term may include a different node type builder.
// This is used as follows:
//
//   foo extends:someClass etc...
//
// Where the default is "default". This is used by the
// component factory to map to a class to represent that node. This is
// SFComponentDescriptionImpl in the default factory.
// This is not documented anywhere (deliberately) and maybe should
// be removed... (IT has been useful in some special uses of the language
// outside of SmartFrog).
//
  final public SFComponentDescription Component() throws ParseException {
  SFComponentDescription component;
  String componentClass="default";
  Token id;
    jj_consume_token(EXTENDS);
    switch (jj_nt.kind) {
    case REFPARTSEP:
      jj_consume_token(REFPARTSEP);
      id = jj_consume_token(WORD);
                                       componentClass = id.image;
      break;
    default:
      jj_la1[31] = jj_gen;
      ;
    }
    component = ComponentType(componentClass);
     {if (true) return component;}
    throw new Error("Missing return statement in function");
  }

  final public SFComponentDescription ComponentType(String componentClass) throws ParseException {
  SFComponentDescription component =
      SFParser.componentFactory(componentClass);
    switch (jj_nt.kind) {
    case ATTRIB:
    case HERE:
    case HOST:
    case PROPERTY:
    case IPROPERTY:
    case ENVPROPERTY:
    case IENVPROPERTY:
    case CONST:
    case LBRACE:
    case NULL:
    case PARENT:
    case PROCESS:
    case ROOT:
    case THIS:
    case WORD:
      EagerComponent(component);
      break;
    case DATA:
    case LAZY:
      DataComponent(component);
      break;
    default:
      jj_la1[32] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return component;}
    throw new Error("Missing return statement in function");
  }

  final public void EagerComponent(SFComponentDescription comp) throws ParseException {
    BaseComponent(comp);
                        comp.setEager(true);
  }

  final public void DataComponent(SFComponentDescription comp) throws ParseException {
    switch (jj_nt.kind) {
    case DATA:
      jj_consume_token(DATA);
      break;
    case LAZY:
      jj_consume_token(LAZY);
      break;
    default:
      jj_la1[33] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    BaseComponent(comp);
                                          comp.setEager(false);
  }

  final public void BaseComponent(SFComponentDescription comp) throws ParseException {
    switch (jj_nt.kind) {
    case NULL:
      jj_consume_token(NULL);
      switch (jj_nt.kind) {
      case COMMA:
      case LBRACE:
        BaseComponentRest(comp);
        break;
      default:
        jj_la1[34] = jj_gen;
        ;
      }
      break;
    case ATTRIB:
    case HERE:
    case HOST:
    case PROPERTY:
    case IPROPERTY:
    case ENVPROPERTY:
    case IENVPROPERTY:
    case CONST:
    case PARENT:
    case PROCESS:
    case ROOT:
    case THIS:
    case WORD:
      BaseComponentLinkType(comp);
      switch (jj_nt.kind) {
      case COMMA:
      case LBRACE:
        BaseComponentRest(comp);
        break;
      default:
        jj_la1[35] = jj_gen;
        ;
      }
      break;
    case LBRACE:
      BaseComponentAttributesType(comp);
      switch (jj_nt.kind) {
      case COMMA:
      case LBRACE:
        BaseComponentRest(comp);
        break;
      default:
        jj_la1[36] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[37] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
       // fix the case when the extends is only of a single {...} as assumptions have been made that
       // type resolution is not required in this case - true before multiple extends!
       // This is done by moving contexts, as the contained CD may be of the wrong node type!
       if (comp.getTypes().size() == 1) {
          Object type = comp.getTypes().firstElement();
          if (type instanceof SFComponentDescription) {
               SFComponentDescription cdType = (SFComponentDescription) type;
               Context cxt = cdType.sfContext();
               comp.setContext(cxt);
               // re-parent any descriptions in super sfContext
               for (Enumeration e = cxt.keys(); e.hasMoreElements(); ) {
                   Object key = e.nextElement();
                   Object value = cxt.get(key);
                   if (value instanceof SFComponentDescription) {
                       ((SFComponentDescription) value).setParent(comp);
                   }
               }
               comp.setTypes(new Vector());
          }
       }
  }

  final public void BaseComponentRest(SFComponentDescription comp) throws ParseException {
    switch (jj_nt.kind) {
    case COMMA:
      jj_consume_token(COMMA);
      switch (jj_nt.kind) {
      case ATTRIB:
      case HERE:
      case HOST:
      case PROPERTY:
      case IPROPERTY:
      case ENVPROPERTY:
      case IENVPROPERTY:
      case CONST:
      case PARENT:
      case PROCESS:
      case ROOT:
      case THIS:
      case WORD:
        BaseComponentLinkType(comp);
        break;
      case LBRACE:
        BaseComponentAttributesType(comp);
        break;
      case NULL:
        jj_consume_token(NULL);
        break;
      default:
        jj_la1[38] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch (jj_nt.kind) {
      case COMMA:
      case LBRACE:
        BaseComponentRest(comp);
        break;
      default:
        jj_la1[39] = jj_gen;
        ;
      }
      break;
    case LBRACE:
      BaseComponentAttributesType(comp);
      break;
    default:
      jj_la1[40] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void BaseComponentLinkType(SFComponentDescription comp) throws ParseException {
   SFReference prototype = null;
    prototype = LinkReference();
    prototype.setEager(true); comp.addType(prototype);
  }

  final public void BaseComponentAttributesType(SFComponentDescription comp) throws ParseException {
   SFComponentDescription compType = SFParser.componentFactory("default");
    jj_consume_token(LBRACE);
    AttributesNoEOF(compType);
    jj_consume_token(RBRACE);
    comp.addType(compType);
  }

  final public SFReference ReferenceNoEOF() throws ParseException {
  SFReference res;
  boolean lazy = false;
    switch (jj_nt.kind) {
    case LAZY:
      jj_consume_token(LAZY);
            lazy = true;
      break;
    default:
      jj_la1[41] = jj_gen;
      ;
    }
    res = BaseReference();
                                                    res.setEager(!lazy);  {if (true) return res;}
    throw new Error("Missing return statement in function");
  }

  final public SFReference BaseReference() throws ParseException {
    SFComponentDescription comp;
    SFReference ref;
    boolean optional = false;
    Object defaultValue = null;
    switch (jj_nt.kind) {
    case ATTRIB:
    case HERE:
    case HOST:
    case PROPERTY:
    case IPROPERTY:
    case ENVPROPERTY:
    case IENVPROPERTY:
    case CONST:
    case OPTIONAL:
    case PARENT:
    case PROCESS:
    case ROOT:
    case THIS:
    case WORD:
      switch (jj_nt.kind) {
      case OPTIONAL:
        jj_consume_token(OPTIONAL);
        switch (jj_nt.kind) {
        case OPSTART:
          jj_consume_token(OPSTART);
          defaultValue = Primitive();
          jj_consume_token(OPEND);
          break;
        default:
          jj_la1[42] = jj_gen;
          ;
        }
                                                              optional = true;
        break;
      default:
        jj_la1[43] = jj_gen;
        ;
      }
      ref = LinkReference();
               ref.setOptional(optional); if (defaultValue!=null) ref.setDefaultValue(defaultValue);
      break;
    case APPLY:
      jj_consume_token(APPLY);
      jj_consume_token(LBRACE);
                       comp = SFParser.componentFactory("default");
      AttributesNoEOF(comp);
      jj_consume_token(RBRACE);
              ref = new SFApplyReference(comp);
      break;
    case ASSERT:
      jj_consume_token(ASSERT);
      jj_consume_token(LBRACE);
                        comp = SFParser.componentFactory("default");
      AttributesNoEOF(comp);
      jj_consume_token(RBRACE);
              ref = new SFAssertReference(comp);
      break;
    default:
      jj_la1[44] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    ref.setEager(true);
    ref.setData(false);
    {if (true) return ref;}
    throw new Error("Missing return statement in function");
  }

  final public SFReference LinkReference() throws ParseException {
    SFReference ref = new SFReference();
    ReferencePart(ref);
    label_10:
    while (true) {
      switch (jj_nt.kind) {
      case REFPARTSEP:
        ;
        break;
      default:
        jj_la1[45] = jj_gen;
        break label_10;
      }
      jj_consume_token(REFPARTSEP);
      ReferencePart(ref);
    }
     {if (true) return ref;}
    throw new Error("Missing return statement in function");
  }

  final public void ReferencePart(SFReference ref) throws ParseException {
  Token id;
    switch (jj_nt.kind) {
    case ROOT:
      jj_consume_token(ROOT);
              ref.addElement(ReferencePart.root());
      break;
    case PARENT:
      jj_consume_token(PARENT);
                ref.addElement(ReferencePart.parent());
      break;
    case ATTRIB:
      jj_consume_token(ATTRIB);
      id = Name();
                          ref.addElement(ReferencePart.attrib(id.image));
      break;
    case HERE:
      jj_consume_token(HERE);
      id = Name();
                        ref.addElement(ReferencePart.here(id.image));
      break;
    case THIS:
      jj_consume_token(THIS);
              ref.addElement(ReferencePart.thisref());
      break;
    case PROPERTY:
      jj_consume_token(PROPERTY);
      id = Name();
                            ref.addElement(ReferencePart.property(id.image));
      break;
    case IPROPERTY:
      jj_consume_token(IPROPERTY);
      id = Name();
                             ref.addElement(ReferencePart.iproperty(id.image));
      break;
    case ENVPROPERTY:
      jj_consume_token(ENVPROPERTY);
      id = Name();
                               ref.addElement(ReferencePart.envproperty(id.image));
      break;
    case IENVPROPERTY:
      jj_consume_token(IENVPROPERTY);
      id = Name();
                                ref.addElement(ReferencePart.ienvproperty(id.image));
      break;
    case CONST:
      jj_consume_token(CONST);
      id = Name();
                        ref.addElement(ReferencePart.constant(id.image));
      break;
    case HOST:
      jj_consume_token(HOST);
      id = Name();
                         ref.addElement(ReferencePart.host(id.image));
      break;
    case PROCESS:
      jj_consume_token(PROCESS);
                 ref.addElement(ReferencePart.process());
      break;
    case WORD:
      id = jj_consume_token(WORD);
                 if (ref.size() == 0) // id in first position - treat as an attrib, not a here
                      ref.addElement(ReferencePart.attrib(id.image));
                 else
                      ref.addElement(ReferencePart.here(id.image));
      break;
    default:
      jj_la1[46] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public Object Basic() throws ParseException {
  Object res, tmp;
  Token id;
    switch (jj_nt.kind) {
    case DATA:
    case FALSE:
    case NULL:
    case TBD:
    case TRUE:
    case VECTORSTART:
    case VAR:
    case STRING:
    case MULTILINESTRING:
    case INTEGER:
    case DOUBLE:
    case LONG:
    case FLOAT:
    case BYTEARRAY:
      res = Primitive();
      break;
    case LBRACKET:
      jj_consume_token(LBRACKET);
                   res = new Vector();
      switch (jj_nt.kind) {
      case APPLY:
      case ASSERT:
      case ATTRIB:
      case DATA:
      case FALSE:
      case HERE:
      case HOST:
      case PROPERTY:
      case IPROPERTY:
      case ENVPROPERTY:
      case IENVPROPERTY:
      case CONST:
      case LAZY:
      case LBRACKET:
      case NULL:
      case OPTIONAL:
      case PARENT:
      case PROCESS:
      case ROOT:
      case TBD:
      case THIS:
      case TRUE:
      case VECTORSTART:
      case OPSTART:
      case IF:
      case SWITCH:
      case VAR:
      case WORD:
      case STRING:
      case MULTILINESTRING:
      case INTEGER:
      case DOUBLE:
      case LONG:
      case FLOAT:
      case BYTEARRAY:
        tmp = SimpleValue();
                               ((Vector)res).addElement(tmp);
        label_11:
        while (true) {
          switch (jj_nt.kind) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[47] = jj_gen;
            break label_11;
          }
          jj_consume_token(COMMA);
          tmp = SimpleValue();
                                       ((Vector)res).addElement(tmp);
        }
        break;
      default:
        jj_la1[48] = jj_gen;
        ;
      }
      jj_consume_token(RBRACKET);
      SFComponentDescription component =
          SFParser.componentFactory("default");
      for (Enumeration e = ((Vector)res).elements(); e.hasMoreElements(); ) {
          Object attribute = e.nextElement();
          component.sfContext().put("unique" + nextId++, attribute);
          if (attribute instanceof SFComponentDescription)
          ((SFComponentDescription)attribute).setParent(component);
      }
      component.sfContext().put("phase.function", functionPhaseClass);
      component.sfContext().put("sfFunctionClass", "org.smartfrog.sfcore.languages.sf.functions.Vector");

      res = component;
      break;
    default:
      jj_la1[49] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return res;}
    throw new Error("Missing return statement in function");
  }

  final public Object Primitive() throws ParseException {
  Object res, tmp;
  Token id;
    switch (jj_nt.kind) {
    case NULL:
      jj_consume_token(NULL);
            res = SFNull.get();
      break;
    case STRING:
    case MULTILINESTRING:
      res = String();
      break;
    case INTEGER:
    case DOUBLE:
    case LONG:
    case FLOAT:
      res = Number();
      break;
    case FALSE:
    case TRUE:
      res = Boolean();
      break;
    case BYTEARRAY:
      res = ByteArray();
      break;
    case VECTORSTART:
      jj_consume_token(VECTORSTART);
                      res = new Vector();
      switch (jj_nt.kind) {
      case DATA:
      case FALSE:
      case NULL:
      case TBD:
      case TRUE:
      case VECTORSTART:
      case VAR:
      case STRING:
      case MULTILINESTRING:
      case INTEGER:
      case DOUBLE:
      case LONG:
      case FLOAT:
      case BYTEARRAY:
        tmp = Primitive();
                             ((Vector)res).addElement(tmp);
        label_12:
        while (true) {
          switch (jj_nt.kind) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[50] = jj_gen;
            break label_12;
          }
          jj_consume_token(COMMA);
          tmp = Primitive();
                                     ((Vector)res).addElement(tmp);
        }
        break;
      default:
        jj_la1[51] = jj_gen;
        ;
      }
      jj_consume_token(VECTOREND);
      break;
    case DATA:
      jj_consume_token(DATA);
      res = BaseReference();
                                   ((SFReference)res).setData(true);
      break;
    case TBD:
      jj_consume_token(TBD);
            res = new SFTBDReference();
      break;
    case VAR:
      res = Var();
      break;
    default:
      jj_la1[52] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return res;}
    throw new Error("Missing return statement in function");
  }

  final public Number Number() throws ParseException {
    Token res;
    Number num;
    switch (jj_nt.kind) {
    case DOUBLE:
      res = jj_consume_token(DOUBLE);
      if (res.image.toUpperCase().charAt(res.image.length() - 1) == 'D')
        num =  Double.valueOf(res.image.substring(0, res.image.length() - 1));
      else
        num =  Double.valueOf(res.image.substring(0, res.image.length()));
      break;
    case FLOAT:
      res = jj_consume_token(FLOAT);
      num = Float.valueOf(res.image.substring(0, res.image.length() - 1));
      break;
    case INTEGER:
      res = jj_consume_token(INTEGER);
      num = Integer.valueOf(res.image);
      break;
    case LONG:
      res = jj_consume_token(LONG);
      num = Long.valueOf(res.image.substring(0, res.image.length() - 1));
      break;
    default:
      jj_la1[53] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return num;}
    throw new Error("Missing return statement in function");
  }

  final public String String() throws ParseException {
    Token res;
    String s;
    switch (jj_nt.kind) {
    case STRING:
      res = jj_consume_token(STRING);
                      s = fixEscapes(res.image.substring(1, res.image.length() - 1));
      break;
    case MULTILINESTRING:
      res = jj_consume_token(MULTILINESTRING);
                               s = fixEscapes(res.image.substring(2, res.image.length() - 1));
      break;
    default:
      jj_la1[54] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  final public Boolean Boolean() throws ParseException {
    Token res;
    Boolean b;
    switch (jj_nt.kind) {
    case TRUE:
      res = jj_consume_token(TRUE);
                    b = Boolean.TRUE;
      break;
    case FALSE:
      res = jj_consume_token(FALSE);
                     b = Boolean.FALSE;
      break;
    default:
      jj_la1[55] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return b;}
    throw new Error("Missing return statement in function");
  }

  final public SFByteArray ByteArray() throws ParseException {
    Token res;
    String s;
    String type;
    res = jj_consume_token(BYTEARRAY);
                         s = eliminateWhitespace(res.image.substring(5, res.image.length() - 1));
                         type = eliminateWhitespace(res.image.substring(1, 4));
      try {
          SFByteArray ba = new SFByteArray(s, type, res.beginLine, res.beginColumn);
          {if (true) return ba;}
      } catch (Exception e) {
          {if (true) throw new ParseException("error constructing binary data:" + e.toString());}
      }
    throw new Error("Missing return statement in function");
  }

  final public Token Name() throws ParseException {
    Token res;
    switch (jj_nt.kind) {
    case STRING:
      res = jj_consume_token(STRING);
                     res.image = fixEscapes(res.image.substring(1, res.image.length() - 1));
      break;
    case MULTILINESTRING:
      res = jj_consume_token(MULTILINESTRING);
                              res.image = fixEscapes(res.image.substring(1, res.image.length() - 1));
      break;
    case WORD:
      res = jj_consume_token(WORD);
      break;
    default:
      jj_la1[56] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
   {if (true) return res;}
    throw new Error("Missing return statement in function");
  }

  public DefaultParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_gen;
  final private int[] jj_la1 = new int[57];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0xbf7ce000,0x80000000,0x80810000,0x80810000,0x10000,0x80000000,0x20000,0x0,0x0,0x0,0xbf7ce000,0x3f60e000,0x3f60e000,0x0,0x7f60e000,0x7f60e000,0xbf7ce000,0xbf74e000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xbf74e000,0x40000000,0x0,0x0,0x7f648000,0x20040000,0x40020000,0x40020000,0x40020000,0x5f608000,0x5f608000,0x40020000,0x40020000,0x20000000,0x0,0x0,0x1f60e000,0x0,0x1f608000,0x20000,0xbf74e000,0x80140000,0x20000,0x140000,0x140000,0x0,0x0,0x100000,0x0,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0xae8f,0x0,0x4100,0x4100,0x0,0x0,0x0,0x0,0x40,0x4000,0xaf8f,0x48e,0x48e,0x0,0x48e,0x48e,0xae8f,0xae8f,0x800000,0x400000,0x20000,0x80000,0x40000000,0x80000000,0x0,0x0,0xfffe0000,0xfffe0000,0xae8f,0x0,0x0,0x40,0x48d,0x0,0x0,0x0,0x0,0x48d,0x48d,0x0,0x0,0x0,0x8000,0x2,0x48e,0x40,0x48c,0x0,0xae8f,0x2a01,0x0,0x2a01,0x2a01,0x0,0x0,0x800,0x0,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x79c688,0x0,0x4400,0x4400,0x0,0x0,0x0,0xc400,0x0,0x4400,0x79c688,0xc400,0xc400,0x39c000,0xc400,0xc400,0x79c68a,0x79c688,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x4,0x5,0x5,0x79c68a,0x0,0x8,0x0,0x400,0x0,0x0,0x0,0x0,0x400,0x400,0x0,0x0,0x0,0x0,0x0,0x400,0x0,0x400,0x0,0x79c688,0x79c200,0x0,0x79c200,0x79c200,0x390000,0xc000,0x0,0xc400,};
   }

  public DefaultParser(java.io.InputStream stream) {
     this(stream, null);
  }
  public DefaultParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new DefaultParserTokenManager(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 57; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 57; i++) jj_la1[i] = -1;
  }

  public DefaultParser(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new DefaultParserTokenManager(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 57; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 57; i++) jj_la1[i] = -1;
  }

  public DefaultParser(DefaultParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 57; i++) jj_la1[i] = -1;
  }

  public void ReInit(DefaultParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 57; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken = token;
    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
    else jj_nt = jj_nt.next = token_source.getNextToken();
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    jj_nt = token;
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
    else jj_nt = jj_nt.next = token_source.getNextToken();
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private java.util.Vector<int[]> jj_expentries = new java.util.Vector<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[87];
    for (int i = 0; i < 87; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 57; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 87; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
