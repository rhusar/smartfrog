package org.smartfrog.sfcore.languages.sf.constraints;


import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Vector;

import org.smartfrog.sfcore.common.Context;
import org.smartfrog.sfcore.common.LinkResolutionState;
import org.smartfrog.sfcore.common.SFNull;
import org.smartfrog.sfcore.componentdescription.ComponentDescription;
import org.smartfrog.sfcore.security.SFClassLoader;

import com.parctechnologies.eclipse.Atom;
import com.parctechnologies.eclipse.CompoundTerm;
import com.parctechnologies.eclipse.CompoundTermImpl;
import com.parctechnologies.eclipse.EXDRInputStream;
import com.parctechnologies.eclipse.EXDROutputStream;
import com.parctechnologies.eclipse.EclipseEngine;
import com.parctechnologies.eclipse.EclipseEngineOptions;
import com.parctechnologies.eclipse.EmbeddedEclipse;
import com.parctechnologies.eclipse.FromEclipseQueue;
import com.parctechnologies.eclipse.QueueListener;
import com.parctechnologies.eclipse.ToEclipseQueue;

/**
 * Implmentation of solver for Eclipse
 */
public class CopyOfEclipseSolver extends PrologSolver  {
	
    // Default Eclipse options
    private EclipseEngineOptions m_eclipseEngineOptions;  
    // Object representing the Eclipse process
    private EclipseEngine m_eclipse;
    
    String m_goal;
    Object m_get_val;
    CDBrowserModel m_cdbm;
    QueueListener m_ql;
    
    String m_core;
    Thread m_ecr;
    
    public void prepareTheory(ComponentDescription cd, String coreFile, String prologFile) throws Exception {
    	m_core = coreFile;
    	
    	//Eclipse Options
		/*m_eclipseEngineOptions  = new EclipseEngineOptions();
	
		// Connect the Eclipse's standard streams to the JVM's
		m_eclipseEngineOptions.setUseQueues(false);
	
		// Initialise Eclipse
		m_eclipse = EmbeddedEclipse.getInstance(m_eclipseEngineOptions);
	
		//Consult core theory file
		m_eclipse.compile(new File(coreFile));
		
		//Consult theory file
	    m_eclipse.compile(new File(prologFile));*/   	
	    
    }
        
    public void runGoal(String goal) throws Exception {	
    	m_eclipse.rpc(goal);
    }
    
    public void stopSolving() throws Exception {
    	m_get_val = new Atom("sfstop");
    	//m_java_to_eclipse.setListener(m_ql);	
    }
    
    public void solve(Context cxt, Vector attrs, Vector values, Vector logic, Vector goal) throws Exception{    	
    	Object _attrs = this.mapValueJE(attrs);
    	Object _values = this.mapValueJE(values);
    	Object _goal = this.mapValueJE(goal);
    	
    	m_get_val = new CompoundTermImpl("sfsolve", _attrs, _values, LinkResolutionState.getLRS().addConstraintEval(cxt), _goal); 
    	
    	if (m_ql==null) m_ql = new EclipseJavaQL();
    	m_ecr = new Thread((Runnable) m_ql); m_ecr.start();
   }
       
    
    private Object mapValueJE(Object v) { 
    	if (v instanceof FreeVar) return v.toString();
    	else if (v instanceof Number) return v;
        else if (v instanceof Vector) {
        	Iterator it = ((Collection)v).iterator();
        	if (!it.hasNext()) return Collections.EMPTY_LIST;
        	LinkedList result = new LinkedList();
            while (it.hasNext()) result.add(mapValueJE(it.next()));
            return result;
        } else if (v instanceof String) return "\""+v+"\"";
        else return null;
    }
    
    private Object mapValueEJ(Object v)  {
		if (v.equals(Collections.EMPTY_LIST)) return new Vector();
    	else if (v instanceof Number) return v;
        else if (v instanceof Collection) {
            Vector result = new Vector();
            Iterator it = ((Collection)v).iterator();  
            while (it.hasNext()) result.add(mapValueEJ(it.next()));
            return result;
        } else if (v instanceof String) return v;
        else throw new SmartFrogEclipseRuntimeException("mapValueEJ: unknown data *from* solver " + v);	
    }	    

    
    class SmartFrogEclipseRuntimeException extends RuntimeException {
    	SmartFrogEclipseRuntimeException(String msg, Throwable cause){
    		super(msg, cause);
    	}
    	SmartFrogEclipseRuntimeException(String msg){
    		super(msg, null);
    	}
    }
    
    EclipseStatus m_est;
    List m_rangeAttrs = new ArrayList();
    EclipseCDAttr m_ecda;
    
    public class EclipseStatus{
    	private boolean done;
    	private int undo;
    	private boolean back;
    	private String ref;
    	private String val;

    	public void undo(){
    		m_get_val = new Atom("back");
			try{
		    	//m_java_to_eclipse.setListener(m_ql);
			} catch (Exception e){
	            throw new SmartFrogEclipseRuntimeException("Unanable to set JtoE listener");            	
	        }
    	}
    	
    	public void done(){
    		m_cdbm.kill();
    		Iterator atiter = m_rangeAttrs.iterator();
    		m_get_val=new Atom("done");
    		while (atiter.hasNext()){
    			EclipseCDAttr ecda = (EclipseCDAttr) atiter.next();
    			try{
    				ecda.cd.sfReplaceAttribute(ecda.name, ecda.val);
    			} catch (Exception e){
		            throw new SmartFrogEclipseRuntimeException("Unable to set attr val in CD after user set");            	
		        }
				try{
    				//m_java_to_eclipse.setListener(m_ql);
				} catch (Exception e){
		            throw new SmartFrogEclipseRuntimeException("Unable to set JtoE listener");            	
		        }
    		}
    	}
    	
        public boolean isDone(){
        	return done;
        }

        public void setBack(boolean back){
        	this.back=back;
        }
        
        public boolean isBack(){
        	return back;
        }
        
        public int getUndo(){
        	return undo;
        }
        
        public String getUndoLabel(){
        	if (ref!=null) return ref+" currently set to "+val;
        	else return "";
        }
    }
    
    
    public class EclipseCDAttr {
    	private Object name;
    	private Object attr;
    	private Object val;
    	private Object range;
    	private boolean set;
    	private ComponentDescription cd;
    	private Class vclass;
    	
    	public boolean isSet(){
    		return set;
    	}
    	
    	public boolean process_sel(String entry){
    		m_ecda = this;
    		Collection c = (Collection) range;
    	    Iterator iter = c.iterator();
    		while (iter.hasNext()){
    			String el = iter.next().toString();
    			if (el.equals(entry)){			
    				m_get_val = new CompoundTermImpl("set", attr.toString(), mapEntryJE(entry));  	
    				try{
    			    	//m_java_to_eclipse.setListener(m_ql);
    				} catch (Exception e){
    		            throw new SmartFrogEclipseRuntimeException("Unanable to reset JtoE listener");            	
    		        }
    				
    				return true;
    			} 
    		}
    		return false;
    	}
    	
    	Object mapEntryJE(String entry){
    		if (m_ecda.vclass==String.class) return entry;
    		else if (m_ecda.vclass==Integer.class){
    			try{
    				return new Integer(Integer.parseInt(entry));
    			} catch (Exception e){
    				throw new SmartFrogEclipseRuntimeException("Unanable to parse Integer entry");  
    			}
    		} else if (m_ecda.vclass==Double.class){
    			try{
    				return new Double(Double.parseDouble(entry));
    			} catch (Exception e){
    				throw new SmartFrogEclipseRuntimeException("Unanable to parse Double entry");  
    			}
    		}
    		throw new SmartFrogEclipseRuntimeException("Unanable to parse entry");  
    	}
        
        public String getRangeAsString(){
    		return range.toString();
    	}
        
    	public Object getAttr(){
    		return attr;
    	}
    	
    	public String toString(){
    		String attr_s1 = attr.toString();
    		String attr_s = attr_s1.substring(1, attr_s1.length()-1);
    		if (set){
    			return ""+attr_s+" has value: "+val;
    		} else {
    			return""+attr_s+" ranges over: "+range;
    		}
    	}
    }
      
    
    class EclipseJavaQL implements QueueListener, Runnable {   	    	
	    FromEclipseQueue m_iqueue = null;
	    EXDRInputStream m_iqueue_formatted = null;
	    ToEclipseQueue m_oqueue = null;
	    EXDROutputStream m_oqueue_formatted = null;
	    boolean m_error=false;
	    String m_error_msg;
	    ToEclipseQueue m_java_to_eclipse;
	    FromEclipseQueue m_eclipse_to_java;
	    
	    // Default Eclipse options
	    private EclipseEngineOptions m_eclipseEngineOptions2;  
	    // Object representing the Eclipse process
	    private EclipseEngine m_eclipse2;
	    
	    
	    
	    public void run(){
	    	try {
	    	    
	    		System.out.println("Hellow I'm boraed");
	    		
	    		m_eclipseEngineOptions2  = new EclipseEngineOptions();
	    		
	    		// Connect the Eclipse's standard streams to the JVM's
	    		m_eclipseEngineOptions2.setUseQueues(false);
	    	
	    		// Initialise Eclipse
	    		m_eclipse2 = EmbeddedEclipse.getInstance(m_eclipseEngineOptions);
	    	
	    		//Consult core theory file
	    		m_eclipse2.compile(new File(m_core));
	    		
	    	    // Set up the java representation of two queue streams
	    	    m_java_to_eclipse = m_eclipse2.getToEclipseQueue("java_to_eclipse");
	    	    m_eclipse_to_java = m_eclipse2.getFromEclipseQueue("eclipse_to_java");

    		    m_eclipse_to_java.setListener(this);	
    		    m_java_to_eclipse.setListener(this);

    			m_eclipse2.rpc("sffromjava");
	    		
	    	} catch (Exception e){} //shouldn't happen
	    }
	    
	    void populateBrowser(){
           Object root = m_cdbm.attr(null, "sfConfig");
	       populateBrowser(top, root);	
	    }
	    
	    void populateBrowser(ComponentDescription cd, Object root){
	    	
	    	Iterator attriter = cd.sfAttributes();
	    	Context cxt = cd.sfContext();
	    	String cxts = create_ref_str(cd);
	    	while (attriter.hasNext()){
	    		Object attr = attriter.next();
	    		
	    		Object val = null;
	    		
	    		try {
	    		   val = cxt.sfResolveAttribute(attr);
	    		}  catch (Exception e){
	    			throw new SmartFrogEclipseRuntimeException("Can not resolve attribute when populating browser", e);
	    		}
	    		
	    		if (val instanceof ComponentDescription){
	    			Object chroot = m_cdbm.attr(root, attr.toString());
	    			populateBrowser((ComponentDescription)val, chroot);
	    		} else {	    		
		    		EclipseCDAttr ecda = new EclipseCDAttr();
		    		ecda.cd = cd;
		    		ecda.name = attr;
		    		ecda.attr = "\""+cxts+attr+"\"";
		    		ecda.val = val;
	                m_cdbm.attr(root, ecda);
	                try {
	                	if (cxt.sfContainsTag(attr, "sfConsUser") && 
	                			(val instanceof FreeVar || val instanceof SFNull)) {
                		   m_rangeAttrs.add(ecda);
                		   ecda.set=false;
                		   
                		   if (cxt.sfContainsTag(attr, "sfConsString")) ecda.vclass = String.class;
                		   else if (cxt.sfContainsTag(attr, "sfConsInteger")) ecda.vclass = Integer.class;
                		   else if (cxt.sfContainsTag(attr, "sfConsDouble")) ecda.vclass = Double.class;
                		   else throw new SmartFrogEclipseRuntimeException("(For now) need to tag sfConsUser attrs with one of sfConsString, sfConsInteger or sfConsDouble");
                		   
	                    } else {
	 		    			ecda.set=true;
	 		    		}
	 	    		}  catch (Exception e){
	 	    			throw new SmartFrogEclipseRuntimeException("Can not check attribute for tag", e);
	 	    		}
		    		
	    		}
	    		
	    	}
	    	
	    }
	    
	    void sfuser(){
	    	
            String classname = System.getProperty("org.smartfrog.sfcore.languages.sf.constraints.CDBrowser");  
            if (classname==null){
            	m_get_val = new Atom("done");
            	return;
            }
            
            try {            
            	m_cdbm = (CDBrowserModel) SFClassLoader.forName(classname).newInstance(); 
            
            } catch (Exception e){
            	throw new SmartFrogEclipseRuntimeException("Can not instantiate CD Browser");
            	
            }
            
            populateBrowser();
            
            
            if (m_rangeAttrs.size()!=0) {
            	
	        	List ranges = new LinkedList();
	        	Iterator raiter = m_rangeAttrs.iterator();
	        	while (raiter.hasNext()){
	        		EclipseCDAttr ecda = (EclipseCDAttr) raiter.next();
                    ranges.add(ecda.getAttr());	        		
	        	}
	     
	        	m_est = new EclipseStatus();
	        	m_cdbm.setES(m_est);
	        	m_get_val = new CompoundTermImpl("range", ranges);
	        	
            } else {
            	m_get_val = new Atom("done");
            }
                	
            
	    }
	    
	    
	    void range(CompoundTerm ct){
	    	Collection c = (Collection)ct.arg(1);
	    	Iterator citer = c.iterator();
	    	Iterator riter = m_rangeAttrs.iterator();
	    	boolean all_done=true;
	    	
	    	while (citer.hasNext()){
	    		EclipseCDAttr ecda = (EclipseCDAttr) riter.next();
	    		Collection range = (Collection) citer.next();
	    		if (range.size()>1) {
	    			ecda.range=range;
	    			ecda.set=false;
	    			all_done=false;
	    		} else {
	    			Iterator range_iter = range.iterator();
	    			ecda.val = mapValueEJ(range_iter.next());
	    			ecda.set=true;
	    		}
	    	}
	    	
	    	m_est.done=all_done;
	    	m_cdbm.redraw();
	    	try{
	    	   m_java_to_eclipse.setListener(null);
	    	} catch (Exception e){
            	throw new SmartFrogEclipseRuntimeException("Unanable to clear JtoE listener");            	
            }
	    }
	    
	    void set(CompoundTerm ct){
	    	m_est.undo = ((Integer)ct.arg(1)).intValue();
	    	String ref = (String)ct.arg(2);
	    	if (ref!=null) m_est.ref = ref.substring(1, ref.length()-1);
	    	Object val = ct.arg(3);
	    	if (val!=null) m_est.val = val.toString();
	    	m_est.back = ct.arg(4).toString().equals("back");
	    	m_get_val = new Atom("range");
	    }
	    
	    // Called when Eclipse flushes source
	    public void dataAvailable(Object source)
	    {	    	
	    		    	
	       if(m_iqueue == null){
			m_iqueue = (FromEclipseQueue) source;
			m_iqueue_formatted = new EXDRInputStream(m_iqueue);
	       }
	
	         CompoundTerm ct = null;
	         try{ 
	           ct = (CompoundTerm) m_iqueue_formatted.readTerm();
	         } catch (IOException ioe){
	        	 throw new SmartFrogEclipseRuntimeException("dataAvailable: Unable to *read* from input stream. ", ioe);
	         }
	         
	         
	         String func = ct.functor();
	         	         
	         if (func.equals("sfuser")){
	        	 sfuser();
	        	 return;
	         }
	         
	         if (func.equals("range")){
	        	 range(ct);
	        	 return;
	         }
	         
	         if (func.equals("set")){
	        	 set(ct);
	        	 return;
	         }
	         
	         if (func.equals("norange")){
	        	 throw new SmartFrogEclipseRuntimeException("Unable to collect range information for sfConsUser tagged attributes. Probably because it has not been set in constraint annotations");
	         }
	         
	         if (func.equals("sfset")){
	        	 int idx = ((Integer) ct.arg(1)).intValue();
	        	 String attr = ct.arg(2).toString();
	        	 Object val = mapValueEJ(ct.arg(3));
	        	 int cidx = ((Integer) ct.arg(4)).intValue();
	        	 LinkResolutionState.getLRS().addConstraintAss(idx, attr, val, cidx);
	         }
	    }
	
	    // Required to implement QueueListener
	    public void dataRequest(Object source)
	    {
	    	System.out.println("dataRequest");
	    	
	    	if(m_oqueue == null){
				m_oqueue = (ToEclipseQueue) source;
				m_oqueue_formatted = new EXDROutputStream(m_oqueue);
		    }
		    	    	
	    	try { 
		    	if (m_get_val!=null) {
		    		m_oqueue_formatted.write(m_get_val);
		    		m_java_to_eclipse.setListener(null);
		    		m_get_val=null;
		    	} else {
		    		throw new SmartFrogEclipseRuntimeException("dataRequest: No data available to write. ");
		    	}
	    	} catch (IOException ioe){
	    		throw new SmartFrogEclipseRuntimeException("dataRequest: Unable to *write* on output stream. ", ioe);
    	    }
	    }
    }
}

